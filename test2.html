<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Tile animation (jQuery)</title>
    <script src="https://code.jquery.com/jquery-3.6.4.min.js"></script>
    <style>
        body {
            background: #111;
            color: #fff;
            font-family: system-ui;
            display: flex;
            gap: 24px;
            align-items: flex-start;
            padding: 32px;
        }
        
        .panel {
            max-width: 540px;
        }
        
        .tile-wrapper {
            position: relative;
            display: inline-block;
            overflow: hidden;
        }
        
        .tile-wrapper img {
            display: block;
            width: 100%;
            height: auto;
        }
        /* keep image responsive if you like */
        /* tiles */
        
        .tile-overlay {
            position: absolute;
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 5;
        }
        
        .tile {
            position: absolute;
            background-repeat: no-repeat;
            will-change: transform, opacity;
            backface-visibility: hidden;
        }
        /* CSS keyframes for in/out */
        
        @keyframes tileFlyIn {
            from {
                opacity: 0;
                transform: translateY(30px) scale(.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        
        @keyframes tileFlyOut {
            from {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            to {
                opacity: 0;
                transform: translateY(-30px) scale(.95);
            }
        }
        /* small UI */
        
        .controls {
            margin-top: 12px;
            display: flex;
            gap: 8px;
        }
        
        button {
            padding: 8px 12px;
            border-radius: 6px;
            border: 0;
            cursor: pointer;
        }
        
        .muted {
            color: #bbb;
            font-size: 13px;
            margin-top: 6px;
        }
    </style>
</head>

<body>

    <div class="panel">
        <h3>Tile animation demo</h3>

        <!-- Your image (same markup you used before) -->
        <div class="tile-wrapper">
            <img src="images/08/Mobile.png" alt="mobile" class="animatedimg" width="500">
            <!-- .tile-overlay will be injected by script -->
        </div>

        <div class="controls">
            <button id="playIn">Play flyIn</button>
            <button id="playOut">Play flyOut</button>
            <button id="recreate">Recreate tiles</button>
        </div>

        <div class="muted">
            Options you can change in the JS: <code>rows</code>, <code>cols</code>, <code>duration</code>, <code>sequence</code>.
        </div>
    </div>

    <script>
        /*
          Tile animation - pure jQuery controller that:
           - splits the image into rows x cols tiles (divs with background-position slices)
           - animates tiles using CSS animations with staggered delays determined by a sequence (tb, lr, random, lrtb)
           - supports 'flyIn' and 'flyOut' effects
        */

        (function($) {
            // helper: shuffle array in-place
            function shuffle(arr) {
                for (let i = arr.length - 1; i > 0; --i) {
                    const r = Math.floor(Math.random() * (i + 1));
                    [arr[i], arr[r]] = [arr[r], arr[i]];
                }
                return arr;
            }

            // sequence creators
            function createSequences(rows, cols, method) {
                method = (method || 'tb').toString();
                if (method === 'lr') {
                    const seq = [];
                    for (let j = 0; j < cols; j++) {
                        const step = [];
                        for (let i = 0; i < rows; i++) step.push([i, j]);
                        seq.push(step);
                    }
                    return seq;
                }
                if (method === 'tb') {
                    const seq = [];
                    for (let i = 0; i < rows; i++) {
                        const step = [];
                        for (let j = 0; j < cols; j++) step.push([i, j]);
                        seq.push(step);
                    }
                    return seq;
                }
                if (method === 'lrtb') { // left->right then top->bottom but one tile per step (fine-grained stagger)
                    const seq = [];
                    for (let i = 0; i < rows; i++)
                        for (let j = 0; j < cols; j++) seq.push([
                            [i, j]
                        ]);
                    return seq;
                }
                if (method === 'random') {
                    const single = [];
                    for (let i = 0; i < rows; i++)
                        for (let j = 0; j < cols; j++) single.push([
                            [i, j]
                        ]);
                    return shuffle(single);
                }
                // fallback to tb
                return createSequences(rows, cols, 'tb');
            }

            // create and style tiles; returns matrix tiles[row][col] with jQuery elements
            function buildTiles($img, rows, cols) {
                const src = $img.attr('src');
                const width = $img.width();
                const height = $img.height();

                // wrapper (the element that wraps image)
                const $wrapper = $img.parent();
                $wrapper.css({
                    position: 'relative',
                    width: width,
                    height: height,
                    display: 'inline-block',
                    overflow: 'hidden'
                });

                // overlay container (top of image)
                let $overlay = $wrapper.find('.tile-overlay');
                if ($overlay.length === 0) {
                    $overlay = $('<div class="tile-overlay"></div>').appendTo($wrapper);
                } else {
                    $overlay.empty();
                }

                // compute tile sizes distributing remainders
                const baseW = Math.floor(width / cols);
                const baseH = Math.floor(height / rows);
                const remW = width - baseW * cols;
                const remH = height - baseH * rows;

                const tiles = [];
                let offsetY = 0;
                for (let r = 0; r < rows; r++) {
                    const rowTiles = [];
                    const useH = (r < remH) ? baseH + 1 : baseH;
                    let offsetX = 0;
                    for (let c = 0; c < cols; c++) {
                        const useW = (c < remW) ? baseW + 1 : baseW;
                        // create tile
                        const $t = $('<div class="tile"></div>').css({
                            left: offsetX + 'px',
                            top: offsetY + 'px',
                            width: useW + 'px',
                            height: useH + 'px',
                            backgroundImage: 'url(' + src + ')',
                            backgroundPosition: (-offsetX) + 'px ' + (-offsetY) + 'px',
                            backgroundSize: width + 'px ' + height + 'px',
                            opacity: 0,
                            transform: 'translateY(20px) scale(.98)'
                        });
                        $overlay.append($t);
                        rowTiles.push($t);
                        offsetX += useW;
                    }
                    tiles.push(rowTiles);
                    offsetY += useH;
                }

                // hide original image while tiles play (for flyIn we'll restore later)
                // we leave it visible by default; caller decides when to hide/show
                return {
                    tiles: tiles,
                    overlay: $overlay,
                    wrapper: $wrapper,
                    imgWidth: width,
                    imgHeight: height
                };
            }

            // main: animate tiles
            function animateTiles($img, opts) {
                opts = $.extend({
                    rows: 10,
                    cols: 10,
                    duration: 2000, // total-ish duration (staggering calculated from it)
                    tileDuration: null, // if null, computed as Math.max(180, duration/4)
                    effect: 'flyIn', // 'flyIn' or 'flyOut'
                    sequence: 'tb', // 'tb','lr','random','lrtb'
                    removeAfter: true, // remove overlay after animation completes
                    onComplete: null
                }, opts || {});

                // ensure image loaded / sized
                function run() {
                    const rows = Math.max(1, parseInt(opts.rows));
                    const cols = Math.max(1, parseInt(opts.cols));
                    const computedTileDuration = opts.tileDuration || Math.max(180, Math.round(opts.duration / 4));

                    const data = buildTiles($img, rows, cols);
                    const tiles = data.tiles;
                    const overlay = data.overlay;
                    const wrapper = data.wrapper;

                    // For flyIn: hide original image until done
                    if (opts.effect === 'flyIn') {
                        $img.css({
                            visibility: 'hidden'
                        });
                        overlay.css('pointer-events', 'none');
                    } else {
                        // for flyOut: keep the image visible but overlay sits above
                        $img.css({
                            visibility: 'visible'
                        });
                    }

                    // create sequence steps
                    const seq = createSequences(rows, cols, opts.sequence);
                    // ensure seq is array of steps; if random returned flattened single steps (as above), we have array already

                    // compute stagger
                    const stepsCount = Math.max(1, seq.length);
                    const totalStagger = Math.max(0, opts.duration - computedTileDuration);
                    const delayPerStep = totalStagger / stepsCount;

                    // For each step, animate its tiles
                    let maxTime = 0;
                    for (let stepIndex = 0; stepIndex < seq.length; stepIndex++) {
                        const step = seq[stepIndex];
                        for (let k = 0; k < step.length; k++) {
                            const rc = step[k];
                            const r = rc[0],
                                c = rc[1];
                            const $tile = tiles[r][c];

                            const tileDelay = Math.round(stepIndex * delayPerStep + (k * 4)); // small intra-step micro stagger
                            const animDuration = computedTileDuration;

                            // set animation properties using inline style and apply the correct animation name
                            if (opts.effect === 'flyIn') {
                                $tile.css({
                                    animationName: 'tileFlyIn',
                                    animationDuration: animDuration + 'ms',
                                    animationTimingFunction: 'cubic-bezier(.18,.9,.3,1)',
                                    animationFillMode: 'forwards',
                                    animationDelay: tileDelay + 'ms'
                                });
                            } else { // flyOut
                                $tile.css({
                                    animationName: 'tileFlyOut',
                                    animationDuration: animDuration + 'ms',
                                    animationTimingFunction: 'cubic-bezier(.18,.9,.3,1)',
                                    animationFillMode: 'forwards',
                                    animationDelay: tileDelay + 'ms'
                                });
                            }

                            // track maximum finish time
                            maxTime = Math.max(maxTime, tileDelay + animDuration);
                        }
                    }

                    // after last tile finishes
                    setTimeout(function() {
                        if (opts.effect === 'flyIn') {
                            // show original image and remove tiles (if requested)
                            $img.css({
                                visibility: 'visible'
                            });
                        } else {
                            // flyOut: hide image
                            $img.css({
                                visibility: 'hidden'
                            });
                        }
                        if (opts.removeAfter) {
                            overlay.remove();
                        } else {
                            // leave tiles in final state
                            overlay.css('pointer-events', '');
                        }
                        if ($.isFunction(opts.onComplete)) opts.onComplete.call($img[0]);
                    }, maxTime + 30);
                }

                // run when image has size (loaded)
                if ($img[0].complete && $img.width() > 0) {
                    run();
                } else {
                    $img.one('load', run);
                    // also try to trigger load if cached (some browsers)
                    if ($img[0].complete) $img.trigger('load');
                }
            }

            // expose to jQuery chain as a convenience
            $.fn.tileAnimate = function(options) {
                return this.each(function() {
                    animateTiles($(this), options);
                });
            };

        })(jQuery);

        // ---- demo wiring ----
        $(function() {
            const $img = $('.animatedimg');

            // default example (20x18 like your original)
            function playIn() {
                $img.tileAnimate({
                    rows: 20,
                    cols: 18,
                    duration: 5000,
                    tileDuration: 900,
                    effect: 'flyIn',
                    sequence: 'tb',
                    removeAfter: true
                });
            }

            function playOut() {
                $img.tileAnimate({
                    rows: 50,
                    cols: 20,
                    duration: 4000,
                    tileDuration: 700,
                    effect: 'flyOut',
                    sequence: 'random',
                    removeAfter: true
                });
            }

            $('#playIn').on('click', function() {
                playIn();
            });
            $('#playOut').on('click', function() {
                playOut();
            });
            $('#recreate').on('click', function() {
                // remove any leftover overlay and reset image visibility
                $img.each(function() {
                    const $i = $(this);
                    $i.css({
                        visibility: 'visible'
                    });
                    $i.parent().find('.tile-overlay').remove();
                });
            });

            // optional: auto-run the in animation on load (comment/uncomment as you prefer)
            // playIn();
        });
    </script>
</body>

</html>